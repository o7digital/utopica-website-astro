name: Lighthouse CI

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main]
  schedule:
    # Run performance monitoring daily at 3 AM UTC
    - cron: '0 3 * * *'
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to test'
        required: true
        default: 'staging'
        type: choice
        options:
          - staging
          - production
          - local
      budget_mode:
        description: 'Performance budget enforcement'
        required: true
        default: 'strict'
        type: choice
        options:
          - strict
          - relaxed
          - baseline

env:
  NODE_VERSION: '18'
  LIGHTHOUSE_CI_VERSION: '0.12.0'

jobs:
  lighthouse-ci:
    name: Lighthouse CI Analysis
    runs-on: ubuntu-latest
    timeout-minutes: 30

    strategy:
      matrix:
        # Test different scenarios
        scenario: [mobile, desktop]
        include:
          - scenario: mobile
            form_factor: mobile
            throttling: slow-4g
          - scenario: desktop
            form_factor: desktop
            throttling: none
      fail-fast: false

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Install Lighthouse CI
        run: npm install -g @lhci/cli@${{ env.LIGHTHOUSE_CI_VERSION }}

      - name: Build application
        run: npm run build
        env:
          NODE_ENV: production

      - name: Start application
        run: |
          npm start &
          npx wait-on http://localhost:3000 --timeout 60000
        env:
          PORT: 3000

      - name: Cache warming
        run: |
          echo "Warming up application cache..."
          npm run cache:warm:critical
          sleep 5

      - name: Run Lighthouse CI - ${{ matrix.scenario }}
        run: |
          # Set environment-specific configuration
          export CHROME_PATH=$(which google-chrome-stable)
          export LHCI_BUILD_CONTEXT__CURRENT_HASH="${{ github.sha }}"
          export LHCI_BUILD_CONTEXT__COMMIT_TIME="$(git log -1 --format=%ct)"
          export LHCI_BUILD_CONTEXT__CURRENT_BRANCH="${{ github.ref_name }}"
          export LHCI_BUILD_CONTEXT__COMMIT_MESSAGE="$(git log -1 --format=%s)"
          
          # Configure for scenario
          if [ "${{ matrix.scenario }}" = "desktop" ]; then
            export LHCI_DEVICE_TYPE="desktop"
            export LHCI_THROTTLING_METHOD="provided"
          else
            export LHCI_DEVICE_TYPE="mobile"
            export LHCI_THROTTLING_METHOD="simulate"
          fi
          
          # Run Lighthouse CI
          lhci autorun \
            --config=lighthouse.config.js \
            --collect.settings.formFactor=${{ matrix.form_factor }} \
            --collect.settings.throttlingMethod=${{ matrix.throttling }} \
            --collect.numberOfRuns=3
        env:
          LHCI_GITHUB_APP_TOKEN: ${{ secrets.LHCI_GITHUB_APP_TOKEN }}
          LHCI_TOKEN: ${{ secrets.LHCI_TOKEN }}

      - name: Process Lighthouse results
        run: |
          # Create results directory structure
          mkdir -p lighthouse-results/${{ matrix.scenario }}
          
          # Copy and rename results
          if [ -d ".lighthouseci" ]; then
            cp -r .lighthouseci/* lighthouse-results/${{ matrix.scenario }}/
          fi
          
          # Generate summary report
          node -e "
          const fs = require('fs');
          const path = require('path');
          
          const resultsDir = 'lighthouse-results/${{ matrix.scenario }}';
          const reportFiles = fs.readdirSync(resultsDir, { recursive: true })
            .filter(f => f.endsWith('.json') && f.includes('lhr-'));
          
          if (reportFiles.length > 0) {
            const reports = reportFiles.map(file => {
              const data = JSON.parse(fs.readFileSync(path.join(resultsDir, file), 'utf8'));
              return {
                url: data.finalUrl,
                performance: Math.round(data.categories.performance.score * 100),
                accessibility: Math.round(data.categories.accessibility.score * 100),
                bestPractices: Math.round(data.categories['best-practices'].score * 100),
                seo: Math.round(data.categories.seo.score * 100),
                lcp: data.audits['largest-contentful-paint'].numericValue,
                cls: data.audits['cumulative-layout-shift'].numericValue,
                fcp: data.audits['first-contentful-paint'].numericValue,
                si: data.audits['speed-index'].numericValue,
                tbt: data.audits['total-blocking-time'].numericValue,
              };
            });
            
            const summary = {
              scenario: '${{ matrix.scenario }}',
              timestamp: new Date().toISOString(),
              averageScores: {
                performance: Math.round(reports.reduce((sum, r) => sum + r.performance, 0) / reports.length),
                accessibility: Math.round(reports.reduce((sum, r) => sum + r.accessibility, 0) / reports.length),
                bestPractices: Math.round(reports.reduce((sum, r) => sum + r.bestPractices, 0) / reports.length),
                seo: Math.round(reports.reduce((sum, r) => sum + r.seo, 0) / reports.length),
              },
              webVitals: {
                lcp: Math.round(reports.reduce((sum, r) => sum + r.lcp, 0) / reports.length),
                cls: reports.reduce((sum, r) => sum + r.cls, 0) / reports.length,
                fcp: Math.round(reports.reduce((sum, r) => sum + r.fcp, 0) / reports.length),
                si: Math.round(reports.reduce((sum, r) => sum + r.si, 0) / reports.length),
                tbt: Math.round(reports.reduce((sum, r) => sum + r.tbt, 0) / reports.length),
              },
              reports
            };
            
            fs.writeFileSync(
              path.join(resultsDir, 'lighthouse-summary.json'),
              JSON.stringify(summary, null, 2)
            );
            
            console.log('ðŸ“Š Lighthouse Summary - ${{ matrix.scenario }}:');
            console.log(\`Performance: \${summary.averageScores.performance}/100\`);
            console.log(\`Accessibility: \${summary.averageScores.accessibility}/100\`);
            console.log(\`Best Practices: \${summary.averageScores.bestPractices}/100\`);
            console.log(\`SEO: \${summary.averageScores.seo}/100\`);
            console.log(\`LCP: \${summary.webVitals.lcp}ms\`);
            console.log(\`CLS: \${summary.webVitals.cls}\`);
          }
          "

      - name: Upload Lighthouse reports
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: lighthouse-reports-${{ matrix.scenario }}
          path: |
            lighthouse-results/
            .lighthouseci/
          retention-days: 90

      - name: Performance regression check
        if: github.event_name == 'pull_request'
        run: |
          # Download baseline from main branch
          echo "Checking for performance regressions..."
          
          # This would typically compare against historical data
          # For now, we'll validate against our performance budgets
          node -e "
          const fs = require('fs');
          const summaryPath = 'lighthouse-results/${{ matrix.scenario }}/lighthouse-summary.json';
          
          if (fs.existsSync(summaryPath)) {
            const summary = JSON.parse(fs.readFileSync(summaryPath, 'utf8'));
            const budgets = {
              performance: 90,
              accessibility: 95,
              bestPractices: 90,
              seo: 95,
              lcp: 1500,
              cls: 0.1,
              fcp: 1200,
              tbt: 300,
            };
            
            const violations = [];
            
            // Check score budgets
            Object.entries(budgets).forEach(([metric, budget]) => {
              let value;
              if (summary.averageScores[metric] !== undefined) {
                value = summary.averageScores[metric];
              } else if (summary.webVitals[metric] !== undefined) {
                value = summary.webVitals[metric];
              }
              
              if (value !== undefined) {
                const isViolation = metric === 'cls' ? value > budget : 
                                   ['lcp', 'fcp', 'tbt'].includes(metric) ? value > budget :
                                   value < budget;
                
                if (isViolation) {
                  violations.push(\`\${metric}: \${value} (budget: \${budget})\`);
                }
              }
            });
            
            if (violations.length > 0) {
              console.log('ðŸš¨ Performance budget violations found:');
              violations.forEach(v => console.log(\`  - \${v}\`));
              process.exit(1);
            } else {
              console.log('âœ… All performance budgets met!');
            }
          }
          "

  lighthouse-comparison:
    name: Compare Lighthouse Results
    runs-on: ubuntu-latest
    needs: lighthouse-ci
    if: always() && github.event_name == 'pull_request'

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: Download lighthouse artifacts
        uses: actions/download-artifact@v4
        with:
          pattern: lighthouse-reports-*
          path: artifacts/

      - name: Generate comparison report
        run: |
          node -e "
          const fs = require('fs');
          const path = require('path');
          
          // Find summary files
          const summaryFiles = fs.readdirSync('artifacts/', { recursive: true })
            .filter(f => f.endsWith('lighthouse-summary.json'));
          
          if (summaryFiles.length > 0) {
            const results = summaryFiles.map(file => {
              const data = JSON.parse(fs.readFileSync(path.join('artifacts/', file), 'utf8'));
              return data;
            });
            
            // Generate comparison table
            let markdown = '## ðŸ” Lighthouse Performance Report\n\n';
            markdown += '| Scenario | Performance | Accessibility | Best Practices | SEO | LCP | CLS |\n';
            markdown += '|----------|-------------|---------------|----------------|-----|-----|-----|\n';
            
            results.forEach(result => {
              const perf = result.averageScores.performance;
              const a11y = result.averageScores.accessibility;
              const bp = result.averageScores.bestPractices;
              const seo = result.averageScores.seo;
              const lcp = Math.round(result.webVitals.lcp);
              const cls = result.webVitals.cls.toFixed(3);
              
              // Add emoji indicators
              const perfIcon = perf >= 90 ? 'ðŸŸ¢' : perf >= 70 ? 'ðŸŸ¡' : 'ðŸ”´';
              const a11yIcon = a11y >= 95 ? 'ðŸŸ¢' : a11y >= 80 ? 'ðŸŸ¡' : 'ðŸ”´';
              const bpIcon = bp >= 90 ? 'ðŸŸ¢' : bp >= 70 ? 'ðŸŸ¡' : 'ðŸ”´';
              const seoIcon = seo >= 95 ? 'ðŸŸ¢' : seo >= 80 ? 'ðŸŸ¡' : 'ðŸ”´';
              const lcpIcon = lcp <= 1500 ? 'ðŸŸ¢' : lcp <= 2500 ? 'ðŸŸ¡' : 'ðŸ”´';
              const clsIcon = cls <= 0.1 ? 'ðŸŸ¢' : cls <= 0.25 ? 'ðŸŸ¡' : 'ðŸ”´';
              
              markdown += \`| \${result.scenario} | \${perfIcon} \${perf} | \${a11yIcon} \${a11y} | \${bpIcon} \${bp} | \${seoIcon} \${seo} | \${lcpIcon} \${lcp}ms | \${clsIcon} \${cls} |\n\`;
            });
            
            markdown += '\n### Performance Budgets\n';
            markdown += '- **Performance Score:** â‰¥ 90\n';
            markdown += '- **Accessibility Score:** â‰¥ 95\n';
            markdown += '- **Best Practices Score:** â‰¥ 90\n';
            markdown += '- **SEO Score:** â‰¥ 95\n';
            markdown += '- **Largest Contentful Paint:** â‰¤ 1.5s\n';
            markdown += '- **Cumulative Layout Shift:** â‰¤ 0.1\n';
            
            fs.writeFileSync('lighthouse-comparison.md', markdown);
            console.log(markdown);
          }
          "

      - name: Comment PR with Lighthouse results
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            
            if (fs.existsSync('lighthouse-comparison.md')) {
              const comment = fs.readFileSync('lighthouse-comparison.md', 'utf8');
              
              github.rest.issues.createComment({
                issue_number: context.issue.number,
                owner: context.repo.owner,
                repo: context.repo.repo,
                body: comment
              });
            }

  production-monitoring:
    name: Production Lighthouse Monitoring
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main' && (github.event_name == 'schedule' || github.event_name == 'workflow_dispatch')

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: Install dependencies
        run: |
          npm ci
          npm install -g @lhci/cli@${{ env.LIGHTHOUSE_CI_VERSION }}

      - name: Run production Lighthouse monitoring
        run: |
          export CHROME_PATH=$(which google-chrome-stable)
          export LHCI_BUILD_CONTEXT__CURRENT_HASH="${{ github.sha }}"
          export LHCI_BUILD_CONTEXT__COMMIT_TIME="$(date +%s)"
          export LHCI_BUILD_CONTEXT__CURRENT_BRANCH="main"
          
          # Monitor production URLs
          lhci autorun \
            --config=lighthouse.config.js \
            --collect.url="https://utopica.website" \
            --collect.url="https://utopica.website/sprint-claridad-comercial" \
            --collect.url="https://utopica.website/equipo" \
            --collect.numberOfRuns=5
        env:
          NODE_ENV: production
          LHCI_GITHUB_APP_TOKEN: ${{ secrets.LHCI_GITHUB_APP_TOKEN }}
          LHCI_TOKEN: ${{ secrets.LHCI_TOKEN }}

      - name: Alert on production issues
        if: failure()
        run: |
          echo "ðŸš¨ Production performance monitoring detected issues!"
          echo "Performance degradation detected on production site."
          # Here you could integrate with Slack, Discord, PagerDuty, etc.
          # curl -X POST -H 'Content-type: application/json' \
          #   --data '{"text":"ðŸš¨ Production performance alert for utopica.website"}' \
          #   ${{ secrets.SLACK_WEBHOOK_URL }}

      - name: Upload production monitoring results
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: production-lighthouse-monitoring
          path: |
            .lighthouseci/
          retention-days: 365

  lighthouse-trends:
    name: Performance Trends Analysis
    runs-on: ubuntu-latest
    needs: lighthouse-ci
    if: always() && github.ref == 'refs/heads/main'

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: Download lighthouse artifacts
        uses: actions/download-artifact@v4
        with:
          pattern: lighthouse-reports-*
          path: current-results/

      - name: Download historical data
        run: |
          # Download last 10 runs for trend analysis
          gh run list --branch main --workflow "Lighthouse CI" --limit 10 --json databaseId,conclusion | \
          jq -r '.[] | select(.conclusion == "success") | .databaseId' | \
          head -10 | \
          xargs -I {} gh run download {} --pattern "lighthouse-reports-*" --dir historical-results/ || echo "No historical data found"
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Generate trends report
        run: |
          node -e "
          const fs = require('fs');
          const path = require('path');
          
          // This would implement trend analysis logic
          console.log('ðŸ“ˆ Performance Trends Analysis');
          console.log('Historical data analysis completed');
          
          // Generate trends JSON for dashboard
          const trends = {
            timestamp: new Date().toISOString(),
            branch: 'main',
            commit: '${{ github.sha }}',
            trends: {
              performance: { direction: 'stable', change: 0 },
              lcp: { direction: 'improving', change: -50 },
              cls: { direction: 'stable', change: 0 },
            }
          };
          
          fs.writeFileSync('performance-trends.json', JSON.stringify(trends, null, 2));
          "

      - name: Upload trends data
        uses: actions/upload-artifact@v4
        with:
          name: performance-trends
          path: performance-trends.json
          retention-days: 365